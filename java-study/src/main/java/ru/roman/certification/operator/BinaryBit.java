/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ru.roman.certification.operator;

/**
 * 1. типы float и double не работают с операторами сдвига
 * 2. BigDecimal, BigInteger - тоже не работают ...
 * 3. Побитовые операторы также являются логическими не ленивыми операторами, при соотвтевующем использовании с булеанами
 *
 * @author churganov_r 19.03.2011
 */
public class BinaryBit {

    public static void main(String[] args) {

        //1. Побитовое И
        int x = 112;
// x:    00000000 00000000 00000000 01110000
        int y = 94;
// y:    00000000 00000000 00000000 01011110
        int z;
        z = x & y;
// z=80: 00000000 00000000 00000000 01010000
        System.out.println(z);


//2. Побитовое ИЛИ
        int x1 = 112;
// x:       00000000 00000000 00000000 01110000
        int y1 = 94;
// y:       00000000 00000000 00000000 01011110
        int z1;
        z1 = x1 | y1;
// z = 126: 00000000 00000000 00000000 01111110
        System.out.println(z1);


//3. Побитовое исключающее ИЛИ        (exactly one)
        int x2 = 112;
// x:      00000000 00000000 00000000 01110000
        int y2 = 94;
// y:      00000000 00000000 00000000 01011110
        int z2;
        z2 = x2 ^ y2;
// z = 46: 00000000 00000000 00000000 00101110
        System.out.println(z2);
        System.out.println("=1=======================================");


//4. Сдвиг влево с учетом знака тоесть
//        - знак подопытного числа может меняться .. .
//        - число по модулю увеличивается и отрицательное и положительное
//        - знаковый бит тоже учавствует в сдвигах ..
//        - новые младшие биты подставляются как 0
//        - отрицательные и положительные стремятся к некому максимуму, тоесть к
//        10000000 00000000 00000000 00000000 (-2147483648) если последний младший бит = 1
//        либо к  00000000 00000000 00000000 00000000 если последний младший бит = 0
//        при его достижении, (тесть при прохождении 32 сдвигов(для Integer)) восстанавливается первоначальное число
//        - в конце операций сдвига может получить так что некоторые старшие биты
//        ушли за пределы числа и тогда мы их потеряем ..
//
// 31:  00000000 00000000 00000000 00011111
// 124: 00000000 00000000 00000000 01111100
// -17: 11111111 11111111 11111111 11101111
// -68: 11111111 11111111 11111111 10111100

        System.out.println(31 << 2);
        System.out.println(-17 << 2);
        System.out.println(Integer.toBinaryString(1234));
        System.out.println(Integer.toBinaryString(-1234));
        System.out.println(Integer.toBinaryString(1235));
        System.out.println(Integer.toBinaryString(1235 << 31));
        System.out.println(Integer.toBinaryString(1234 << 31));
        System.out.println(Integer.toBinaryString(-1235 << 31));
        System.out.println(Integer.toBinaryString(-1234 << 31));
        System.out.println(Integer.toBinaryString(1235 << 32));
        System.out.println(Integer.toBinaryString(-1234 << 32));
        System.out.println("=2=======================================");
        System.out.println(Integer.toBinaryString(new Character('c') << 31));
        System.out.println(Integer.toBinaryString(new Short("33") << 31));
        System.out.println(Integer.toBinaryString(new Byte("33") << 31));
        System.out.println(Integer.toBinaryString(new Integer('c') << 31));  // char воспринимается как число
        System.out.println(new Long("1235") << 31);   // метод Integer.toBinaryString не работат с Long, Float, Double, т к он работает с int , остальные типы преобразуются как расширение типа
        System.out.println(new Integer("1235") << 31);
        //System.out.println(new BigDecimal("c") << 31);  // не работает
        //System.out.println(new BigInteger("345") << 31);  // не работает
        System.out.println("=21=======================================");

//5. Сдвиг вправо с учетом знака, тоесть
//  - знак всегда остается
//  - число по модулю уменьшается и отрицательное и положительное
//  - для отрицательных чисел все впереди стоящие единицы, остаются и
//  даже генерируются новые еденицы, таким образом число стремится к -1
//  и стрший бит заменяется всегда на 1
//  - для положительных битов старшие заменяются нулями, число стремится к 0
//  - при сдвиге вправо, младшие биты теряются .. и получается , что
//  здвиг различных чисел приводит  одному результату
// -17:11111111 11111111 11111111 11101111
// -5: 11111111 11111111 11111111 11111011
        System.out.println(-17 >> 2);
        System.out.println(-18 >> 2);
        System.out.println(21 >> 2);
        System.out.println(22 >> 2);
        System.out.println(-21 >> 10000);
        System.out.println(22 >> 10001);
        System.out.println("=3=======================================");


//6. Сдвиг вправо без учета знака
//        - тоесть у отрицательных чисел старшие биты заполняются нулями
//          как и у положительных,
//        - положиельные числа уменьшаются и стремятся к 0 (при 31 итерации всегда = 0),
//            при достижении 0 число восстанавливается к певоначальному виду
//        - отрицательные числа сначала превращаются в положительные потом
//          уменьшаются по модулю и стремятся к 1 (при 31 итерации всегда = 1)
//        - при достижении 1 отриц число восстанавливается к певоначальному виду
//        - восстановление числа происходит , если делать сдвиг одной операцией,
//          если сдвигать несколькими итерациями, определенные биты могут быть утеряны


// -17:        11111111 11111111 11111111 11101111
// 1073741819: 00111111 11111111 11111111 11111011
        System.out.println(-17 >>> 2);
        System.out.println(17 >>> 2);

        System.out.println(-17 >>> 31);
        System.out.println(-1745 >>> 31);
        System.out.println(-1734564 >>> 31);

        System.out.println(17 >>> 31);
        System.out.println(1732 >>> 31);
        System.out.println(1732453 >>> 31);

        System.out.println(17 >>> 32);
        System.out.println(-17 >>> 32);
        System.out.println(-17 >>> 30 >>> 2);
        System.out.println("=4=======================================");


    }
}
