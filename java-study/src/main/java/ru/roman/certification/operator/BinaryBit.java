/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ru.roman.certification.operator;

/**
 * 1. типы float и double не работают с операторами сдвига
 * 2. BigDecimal, BigInteger - тоже не работают ...
 * 3. Побитовые операторы также являются логическими не ленивыми операторами, при соотвтевующем использовании с булеанами
 *
 * @author churganov_r 19.03.2011
 */
public class BinaryBit {

    public static void main(String[] args) {


        int z = 112 & 94;  //...01010000 = ...01110000 & ...01011110
        int z1 = 112 | 94; //...01111110 = ...01110000 | ...01011110
        int z2 = 112 ^ 94; //...00101110 = ...01110000 ^ ...01011110

        System.out.println("=1=>>> " + z);

//4. Сдвиг влево с учетом знака тоесть
//        - знак подопытного числа может меняться .. .
//        - число по модулю увеличивается и отрицательное и положительное
//        - знаковый бит тоже учавствует в сдвигах ..
//        - новые младшие биты подставляются как 0
//        - отрицательные и положительные стремятся к некому максимуму, тоесть к
//        10000000 00000000 00000000 00000000 (-2147483648) если последний младший бит = 1
//        либо к  00000000 00000000 00000000 00000000 если последний младший бит = 0
//        при его достижении, (тесть при прохождении 32 сдвигов(для Integer)) восстанавливается первоначальное число
//        - в конце операций сдвига может получить так что некоторые старшие биты
//        ушли за пределы числа и тогда мы их потеряем ..
//
// 31:  00000000 00000000 00000000 00011111
// 124: 00000000 00000000 00000000 01111100
// -17: 11111111 11111111 11111111 11101111
// -68: 11111111 11111111 11111111 10111100

        int r01 = 1 << 2;     // ...00000100
        int r02 = -1 << 2;    // ...11111100
        int r03 = 1 << 31;    // 1000000...
        int r04 = 1 << 32;    // ...001 без сдвига
        int r05 = 1 << 33;    // ...010
        int r61 = 5 << -2;     // 010000... минус двигает в обратку, правый конец вылазит слева
                               // всё остальное правее заполнется нолями
        int r62 = -1 << -5;    // 11111000000....
        int r07 = 1 << -31;     // ...010
        long r08 = 1L << -63;     // ...010 long длинн

        int r10 = new Character('c') << 32;  // 1100011
        int r11 = new Short("1") << 32;        // 1
        int r12 = new Byte("1") << 32;         // 1
        int r13 = new Integer('c') << 32;   // 1100011
        long r14 = new Long(1L) << 32;   // ...00000100000000000000000000000000000000

        System.out.println("=2=>>> " + Integer.toBinaryString(r62));



//5. Сдвиг вправо с учетом знака, тоесть
//  - знаковый бит всегда остается, даже если двигать с минусом
//  - число по модулю уменьшается и отрицательное и положительное
//  - для отрицательных чисел стрший бит заменяется всегда на 1, таким образом число стремится к -1
//  - для положительных битов старшие заменяются нулями, число стремится к 0
//  - младшие биты безвозвратно теряются
//  - максимальный сдвиг приводит приводит к 0 либо -1

        int l01 = 1 >> 1;     // 0
        int l02 = -1 >> 1;     // ...1111111111 не меняет значение для -1
        int l03 = 0x7fffffff >> 30;     // ...000001
        int l04 = 0x7fffffff >> -4;     // ..0000111  минус двигает наоборот, правый конец вылазит справа
                                        // при этом остаток слева заполняется старшим битом
        int l05 = 0x7fffffff >> 28;     // ..0000111
        int l0 = 0x80000000 >> -4;      // ..1111000

        System.out.println("=3=>>> " + Integer.toBinaryString(l0));

//6. Сдвиг вправо без учета знака
//        - протипоположен оператору <<
//        - у отрицательных чисел старшие биты заполняются нулями как и у положительных
//        - положиельные уменьшаются, отрицательные превращаются в положительные и тоже уменьшаются
//        - положительные стремятся к 0, отрицательные к 1
//        - младшие биты теряются безвозвратно

        int h01 = 1 >>> 1;           // 0
        int h02 = 2 >>> 1;           // 1
        int h03 = -1 >>> 31;         // 1
        int h04 = -1 >>> -1;         // 1 минус двигает наоборот, правый конец вылазит справа
                                     // при этом остаток слева заполняется нолями
        int h05 = 0x7fffffff >>> -2;  // 1

        //int e0 = 1f >>> 1;  // illegal
        //int e1 = 1 >>> 1f;  // illegal


        System.out.println("=4=>>> " + Long.toBinaryString(h0));

    }
}
