/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ru.roman.certification.primitives;

/**
 * http://www.znannya.org/?view=Java_PrimitiveTypesOp
 * <p>
 * 1. В Java, как и в языке C, преобразования типов при вычислении выражений
 * могут выполняться автоматически, либо с помощью оператора приведения типа.
 * Однако правила приведения типов несколько отличаются от правил языка C, и в
 * целом являются более строгими, чем в языке C.
 * <p>
 * 2. При выполнении операции присваивания преобразование типов происходит
 * автоматически:
 * - если происходит расширяющее преобразование (widening conversion)
 * - два типа совместимы.
 * byte -> short -> int -> long -> float -> double.
 * <p>
 * 3. Числовые типы не совместимы с типами char и boolean для преобразоваий
 * Типы char и boolean не совместимы также и друг с другом.
 * <p>
 * 4. В языке Java выполняется автоматическое преобразование типов также и при
 * сохранении литеральной целочисленной константы (которая имеет по умолчанию тип
 * int) в перемен­ных типа byte, short или long (однако если литерал имеет
 * значение вне диапазона допустимых значений для данного типа, выдается сообщение
 * об ошибке: возможная потеря точности).
 * <p>
 * 5. Если преобразование является сужающим (narrowing conversion), т. е.
 * выполняется преобразование
 * byte <- short <- char <- int <- long <- float <- double, то такое
 * преобразование может привести к потере точности числа или к его искажению.
 * Поэтому при сужающих преобразованиях при компиляции программы выводится
 * диагностическое сообщение о несовместимости типов и файлы классов не создаются.
 * <p>
 * 6. Если все же необходимо выполнить сузжающие преобразования, используется операция
 * приведения (cast) типа, которая имеет следующий формат: (тип-преобразования) значение
 * <p>
 * 7. Если значение с плавающей точкой присваивается целому типу, то (если значение
 * с плавающей точкой имеет дробную часть) при явном преобразовании типа происходит
 * также усечение (truncation) числа.
 * <p>
 * 8. Если же присваиваемое значение лежит вне диапазона типа-преобразования, то
 * результатом преобразования будет остаток от деления значения на модуль диапазона
 * присваиваемого типа (для чисел типа
 * byte модуль диапазона будет равен 256 (|мин. значение | + макс. значение + 1(ячейка под ноль))
 * short    – 65536,
 * int      – 4294967296
 * long     – 18446744073709551616
 * <p>
 * 9. При преобразовании целых или вещественных чисел в данные типа char,
 * преобразование в символ происходит, если исходное число лежит в диапазоне от
 * 0 до 127, иначе символ получает значение '?'.
 * <p>
 * 10. При выполнении арифметических и побитовых преобразований все значения byte
 * и short, а также char расширяются до int, (при этом в вычислениях для char
 * используется числовое значение кода символа) затем, если хотя бы один операнд
 * имеет тип long, тип целого выражения расширяется до long. Если один из операндов
 * имеет тип float, то тип полного вы­ражения расширяется до float, а если один
 * из операндов имеет тип double, то тип результата будет double.
 * <p>
 * 11. вещественные константы по умолчанию имеют тип double
 * <p>
 * 12. Автоматические расширения типов (особенно расширения short и byte до int)
 * могут вызывать плохо распознаваемые ошибки во время компиляции. Например, в операторах:
 * byte x = 30, y = 5;
 * x = x + y;
 * перед выполнением умножения значение переменных x и y будет расширено до int,
 * а затем при выполнении попытки присвоения результата вычисления типа int переменной
 * типа byte будет выдано сообщение об ошибке.
 * Чтобы этого избежать надо использовать во втором операторе явное преобразование типов:
 * x = (byte) (x + y);
 * Выражение x + y необходимо заключит в скобки потому, что приоритет операции
 * приведения типа, заключенной в скобки, выше, чем приоритет операции сложения.
 * Кстати, если записать второй оператор в виде:
 * x += y;
 * то сообщения об ошибке не будет, в комбинированных операторах происходит автоматическое преобразование типа
 *
 * @author churganov_r 21.03.2011
 */
class TypeConversion {

    public static void main(String[] args) {

        byte b0 = 1, b2 = 127;
        //b0 = b0 * b2;           // illegal
        b0 += b2;                 // не явное преобразование
        b0 = 1 * 127;
        b0 = (byte) (b0 * b2);    // приоритет Cast выще чем у умножения
        long l1 = 1;
        b0 = (byte) l1++;        // но ниже чем у декремента
        byte b3 = 'Z';
        //byte b4 = 'Ф';        // illegal, слишком велик код


        //short s0 = 1.1;        // illegal
        short s1 = 'Ф';
        //short s2 = '한';       // illegal


        //char c1 = -1;       // illegal
        char c2 = 0xFFFF;
        //char c3 = 0x1FFFF;   // illegal
        byte b1 = 1;
        //char j1 = b1;         // illegal, не совместимо т к оно может быть отрицательно
        char c4 = '한';       // графема из 1 Unicode символа
        int i3 = '한';       // графема из 1 Unicode символа
        //char c4 = '한';     // illegal графема из 3 Unicode символов, литерал одного символа не может быть из трех
        //int i4 = '한';      // illegal графема из 3 Unicode символов, аналогичо
        //char c6 = 1L;       // illegal


        byte b8 = (byte) 128;  // -128 на единицу зашло в отрицательные
        byte b9 = (byte) 129;  // -127
        byte b10 = (byte) 255;  // -1
        byte b11 = (byte) 256;  // 0 полный диапазон, круг замкнулся
        byte b12 = (byte) 257;  // 1


        char c8 = (char) 48; // '0'
        char c7 = (char) 0xFFFFF; // ￿/'?'  - любое число вне диапазона привращается в символ '?'
        char c9 = (char) (0xFFFF + 49); // '0' - не совсем любое

        //System.out.println(c7);

        foo();
        foo1();
    }

    private static void foo() {

        byte r11 = (byte) 3e10;                         // -1
        short r12 = (short) Double.NEGATIVE_INFINITY;   // 0
        int r13 = (char) 3e10;                          // 65535
        int r = (int) Float.POSITIVE_INFINITY;          // 2147483647
        int r14 = (int) .99999997f;                     // 0
        int r15 = (int) .99999998f;                     // 1
        int r16 = (int) .99999999999999994;             // 0
        int r17 = (int) .99999999999999995;             // 1
        long r18 = (long) 2e19;                       // 9223372036854775807

        System.out.println(r);
    }

    private static void foo1() {
        System.out.println("(short)0x12345678 == 0x" + Integer.toHexString((short) 0x12345678));
        System.out.println(0x12345678 + " vs " + (short) 0x12345678);
    }
}
