/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ru.roman.certification.primitives;

import java.math.BigDecimal;

/**
 * 1. String не является примитивом, всего примитивов 8
 * <p>
 * 4. Существует также специальный нулевой тип, тип выражения
 * null, который не имеет имени, он не имеет класса обертки и примитивом не является
 * <p>
 * 5. Есть тип void - имеет класс обертку и примитивом не является.
 * <p>
 * 5.1 В Java есть ссыочные типы и примитивные типы ..
 * <p>
 * 6. Ссылочные типы – это типы
 * - классов, интерфейсов, массивов.
 * <p>
 * 7.
 * <p>
 * 8. При указании литерала примитивного значения можно указать тип значения, например
 * 34L - , в этом случае мы принудительно указываем тип значения,
 * <p>
 * 9. Языки типа JScript - интерпретирующего типа как правило являются языками
 * со свободной типизацией ..(loose typed language)
 * <p>
 * 10. Языки компилирующего типа как Java являются как правило языками со
 * строгой типизацией . ..(strongly typed language)
 * <p>
 * 11. Тип
 * - ограничивает набор значений, которые могут быть присвоены переменной,
 * - либо получены в выражении,
 * - ограничивает операции над значениями
 * - определяет реализацию конкретной операции.
 * <p>
 * <p>
 * 12. Целочисленные константы могут задаваться в программе одним из трех способов:
 * - в виде десятичных,        1
 * - шестнадцатеричных         0х1
 * - восьмеричных значений.    01
 * <p>
 * 13. По умолчанию все числа интерпретируются как десятичные и относятся
 * к типу int , а с точкой и со степенью к типу double
 * <p>
 * 14. Явно указать принадлежность к типу можно, добавив в конце числа букву
 * "l"("L"), "d"("D"), "f"("F").
 * - эти буквы нужны чтобы компилятор не ругался при проверке числа, если
 * оно например слишком большое для int
 * - float вообще нельзя определить без буквы f
 * <p>
 * 15. Шестнадцатеричное значение задается с помощью символов "0x" или "0X",
 * за которым значение числа (цифры 0-9 и буквы A-F или a-f), например: 0x7FFF.
 * <p>
 * 16. Число в восьмеричной записи должно начинаться с нуля, за которым следует
 * одна или несколько восьмеричных цифр, например 077777.
 * <p>
 * 17       10000   = -0x80
 * 11111   = -0x80 - -1
 * 11110   = -0x80 - -2
 * 10001   = -1
 * 00000   = 0
 * 00001   = 1
 * 01111   = 0x7F
 * <p>
 * 18 Символы в Java реализованы с использованием стандарта Unicode.
 * Можно задать константу-символ в про­грамме или как обычный символ.
 * - Символьное значение должны быть заключено в пару одиночных апострофов, например
 * char symbol='f';
 * - Другой способ записи символов: пара символов u, за которой следует
 * четырехзначное шестнадцатеричное число (в диапазоне от 0000 до FFFF),
 * представляющее собой код символа в Unicode, например
 * char symbol = '\u0042';  // и только в одинарных кавычках
 * если таким образом задававать символы - ескейп последовательности.
 * то нужно указывать оба символа ескейп последовательности тоесть так
 * char f91 = '\u005C\u005C';
 * - можно также сделать вот так
 * char symbol = 0x42; // и это тоже самое
 * - спец символы типа char задаются специальными escape последовательностями..
 * <p>
 * 19 Если мы говорим char a4 = 0x434;
 * это не то самое что char a4 = 434;
 * т к по умолчанию литерал числа воспринимается как десятичное число ..
 * <p>
 * <p>
 * 20 У Double и Float целая часть от мантисы отделяется точкой
 * <p>
 * 21 число -3,58 на десять в седбмой можно также записать как –3.58E7
 * а число 73,675 на 10 в минус петнадцатой как 73.675e-15,
 * у 16-ричного числа e меняется на p т.к. e - в 16-ричной системе это цифра
 * <p>
 * 22 Переменные с плавающей точкой могут хранить не только численные значения,
 * но и любой из особо определенных флагов (состоянии):
 * - отрицательная беско­нечность,
 * - отрицательный нуль,
 * - положительная бесконечность,
 * - положительный нуль
 * - «отсутствие числа» (not-a-number, NaN).
 * <p>
 * 23 Все константы с плавающей точкой подразумеваются принадлежащими к типу
 * double. Чтобы задать число типа float, необходимо добавить в его конец
 * символ "f" или символ "F".
 * - Литерал в целой часть равной нулю можно обозначить как .5 например вместо
 * 0.5
 * <p>
 * 24 Большинство операций над примитивными типами выполняется не с помощью
 * методов, а с помощью специальных символов, называемых знаком операции.
 * <p>
 * 25 Переменные булевского типа (логические переменные) могут принимать одно
 * из двух значений: «истина» или «ложь»
 * В отличие от C, где результату «ложь» сопоставлено целое значение типа int
 * равное 0, а результату «истина» – ненулевое значение типа int , тоесть 1, 2 ,
 * - 1 и т п ..., и соответственно, результатам сравнения присваивается целое
 * значение (обычно 0 или 1), в Java для булевских переменных введен свой,
 * отдельный тип данных boolean
 * <p>
 * 26 Действия с булевыми типами
 * - инициализация
 * - операции сравнения, арифметические и др.
 * - вывод в консоль
 *
 * @author дтоь 12.01.2008
 */
public class Primitives {

    // числовые типы
    // целые типы           размер      мин                 макс
    static byte a5;         //8         -128                127         знаковый
    static short a1;        //16       -32768               32767       знаковый
    static int a2;          //32       -2147483648          2147483648  знаковый
    static long a3;         //64       -922372036854775808  922372036854775807  знаковый

    static char a4;         //16        0                   65536       беззнаковый

    // числовые типы
    // вещественные типы                                        точность
    static float a6;        //32        3,4e-38 < |x| < 3,4e38      7-8 цифр
    static double a7;       //64        1,7e-308 < |x| < 1,7e308    17 цифр
    //булевский тип
    static boolean a8;      //8         true/false

    public static void main(String[] args) {

        {
            byte b1 = 0x7f; // это не литерал byte, но литерал int, однако компилятор не требует приведения
            //byte b2 = 0x80; // illegal hex для отрицательного не работает, литерал 0x80 воспринимается как int литерал и он вылизит за границы byte
            //byte b2 = 0x80b; // illegal у byte нет своего спец литерала

            int i = 1;
            // byte b3 = i;  //  illegal
            System.out.println(b1);
        }

        {
            short s1 = Short.MIN_VALUE;
            short s2 = -32_768;
            short s3 = -3____2____7___6__8;
            short s4 = 0xA_b_A;
            short s5 = 0_07_7;
            short s6 = 0B0_________01_1;
            //short s6 = 0077_;  // illegal
            //short s7 = _0077;  // illegal

            System.out.println(s1);
        }
        {
            int i1 = 1;
            int i2 = 0x1;
            int i21 = 0XfFbFAFfF;
            int i3 = 07;
            int i33 = 0000007;
            int i77 = 0b0;
            int i78 = 0B0;
            //int i4 = 09; // illegal
            int i6 = -0XCAFEBABE;
            int i7 = 0x7fffffff; // Integer.MAX_VALUE
            int i8 = 0x80000000; // Integer.MIN_VALUE
            int i9 = 0xFFFFFFFF; // -1  литерал отрицательного числа не имеет минуса в hex (с Integer и Octal так нельзя)
            int i99 = 0b11111111111111111111111111111111; // -1
            // int i98 =  2147483648; // illegal Integer, по идее это -2147483648
            // int i99 =  040000000000; // illegal Octal, по идее это -2147483648
            int i98 = -2147483648; // Integer.MIN_VALUE - исключение, компилятор разрешает недопустимый литерал с отрицанием
            int i10 = -0xFFFFFFFF; // отрицание -1 есть 1
            // операиция отрицание это все единицы переводятся в ноли и младшему биту прибавляется единица
            int i11 = -0000000000000000000000000000000000000000000000000000000; // нули компилятся норм
            // int i12 = -0x2p2; // illegal double не int
            int i13 = -0x2e2;

            System.out.println(-0xFFFFFFFF == 0x1);  // true
            System.out.println(-i8 == i8);  // true - отрицание минимального числа не приводит по факту к его изменению (исключение)
            System.out.println(i99);
            System.out.println(Integer.MAX_VALUE);
        }

        {
            long l1 = 1l;
            long l2 = 1L;
            long l3 = 1;

            //long l4 = 1000000000000000000;  // illegal, т к литерал int
            long l5 = 1000000000000000000L;
            long l6 = -9223372036854775808L;  // Long.MIN_VALUE, аналогичное исключение
            long l7 = 9223372036854775807L;  // Long.MIN_VALUE, аналогичное исключение
            // long l8 = 0b1010000101000101101000010100010110100001010001011010000101000101;   // illegal, т к литерал int, хоть и binary
            long l31 = 0b1111111111111111111111111111111111111111111111111111111111111111L;
            long l9 =  0b1010000101000101101000010100010110100001010001011010000101000101L;

            System.out.printf("longs: %s %n", l31);
        }

        {
            float f1 = 0;
            float f15 = 0x0;
            // float f17 = 0.0;
            float f25 = 0x0F; // это не float 0 а это 15
            float f16 = 00;
            //float f11 = .0;   // illegal т к double
            float f12 = 0L;   // норм, т к может представлять гораздо большие значения чем long
            float f13 = (float) .0;
            float f2 = 0.0f;
            float f3 = 0.0F;
            float f41 = 0.F;
            float f4 = .0F;
            float f5 = 0F;
            float f6 = 09F;
            float f7 = .000000000000000000000000000000000000000000001F;
            //float f8 = .0000000000000000000000000000000000000000000001F; // illegal
            float f10 = .1000000000000000000000000000000000000000000000000000000000000000000000000000000000001F;
            float f11 = 100000000000000000000000000000000000000F;
            float f17 = 100000000000000000000000000000000000000.0F;
            float f18 = 100000000000000000000000000000000000000.000000000000000000000000000000000000000000000000000000000001F;
            float f19 = 00000000000000000000000000000000000000000000000.0000000000000000000000000000000000000000000000000000F;
            float f20 = Float.intBitsToFloat(0x7fc00000);
            float f21 = Float.intBitsToFloat(2143289344);
            float f22 = Float.NaN;
            float f23 = 0.0f / 0.0f;
            float f24 = 3.7e6f;
            float f34 = -1.8E-7f;
            BigDecimal.valueOf(-1.8E-7f).toPlainString();
            float f45 = (float) -2e1;
            float f44 = 0x1e;
            float f46 = (float) -0x2p2;

            System.out.printf("floats: %s %n", 3.4e38f * 2 * 0);

        }

        {
            double d1 = 0;
            double d2 = .0;
            double d21 = 0.;
            double d3 = 0.0;
            double d4 = 0.0d;
            double d5 = 0.0D;
            double d51 = 0D;       // с D можно без точки
            double d52 = 0xffffffffffffffffL;  // длиннее нельзя т к это long литерал
            double d53 = 000999999999999999999999999999999999999999999999999999999999999999999999999999999999999999d;
            //double d55 = 0.0_D; // illegal
            //double d55 = 0._0D; // illegal
            //double d55 = 0_.0D; // illegal
            double d56 = 0.0_0D; // норм, нули на хвосте игнорятся, подчеркивание можно
            double d6 = 0.0F;
            double d7 = 0xF;
            //double d8 = 09;
            double d9 = 09d;
            double d10 = 0.0f; // 0
            double d11 = 0x0f; // 15
            double d12 = 1.7e308; //
            double d13 = -0; //
            double d14 = -0D; //

            System.out.printf("doubles: %s %n", -0D == 0D);
        }
        {
            boolean b1 = false;
            boolean b2 = true;
        }

        {
            char vv = (byte)127;
            //char v2 = (byte)128;    // illegal хотя и влазит в char, при кастинге к byte оно станет равно -128
            char vb = (short)32_767;
            //char vv = (byte)-1;     // illegal

            char c1 = 'f';
            char c2 = '\u0042';       // только в одинарных кавычках, от 0000 до FFFF, код символа в Unicode
            char c3 = '\u005C\u005C'; // если таким образом задававать символы - ескейп последовательности
                                      // то нужно указывать оба символа ескейп последовательности тоесть так
            char c4 = 0x42;
            char c5 = 0x434;
            char c6 = 434;
            // char c7 = 99999; //
            // char c7 = (char) "c"; // illegal
            // char c8 = -1; // illegal
            // char c9 = 1.0;
            char c10 = 0177777;
            char c11 = 0b1111111111111111;
            char c12 = '\377';
            char c13 = '\n';
            char c14 = '\'';
            char c15 = '\\';
            char c16 = '™';
            char c17 = '\uuuuuuuuuuuuuuuuuu0177';

            System.out.printf("chars: %s %n", '\uuuuuuuuuuuuuuuuuu0177' == '\u0177');
        }

        // При сравнении литералы приводятся к значению в int
        System.out.printf("1. %s%n", 34.00000000000000D == 34L);
        // Для  float и double признаки 8-ричной и 16-ричной системы игнорятся
        System.out.printf("2. %s%n", 04.0F == 0x4);
        // У char после \\u указывается 16-ричный символ, в операциях char приводится к числу
        System.out.printf("3. %s%n", 0x434 == '\u0434');
        System.out.printf("31. %s%n", 434 == '\u0434');
        // double и float Java хранит в виде записи типа значение * 10 в степени ...,
        // поэтому поддерживаются очень большие значения, но число по факту округляется,
        // поэтому не работает сравнение и арифметические операции не точны
        System.out.printf("4. %s%n",
                3444444444444444444d
                        == 3444444444444444444l);
        //
        System.out.printf("5. %s%n",
                34444444444444444444444444444444444444f
                        == 34444444444444444444444444444444444444d);
        // у вещественного типа есть отрицательный ноль
        System.out.printf("6. %s%n", -0d == 0d);
        // у целого нет
        System.out.printf("7. %s%n", -0 == 0);
        // операции над вещественными типами происходят несколько иначе, на выходе можно получить например -Infinity
        // если хотябы один из операндов double, второй тоже Java приводит к double
        System.out.printf("8. %s%n", -1022f / 0l);

        //System.out.printf("9. %s%n", 1l / 0l); java.lang.ArithmeticException: / by zero
        System.out.printf("9. %s%n", 0l / 1l);

        System.out.printf("9.1. %s%n", 0.0 / 0.0);
        System.out.printf("9.2. %s%n", 0.0 / 0.0 == 0.0 / 0.0);
        System.out.printf("9.3. %s%n", 0.0 / 0.0 == -(0.0 / 0.0));
        System.out.printf("9.4. %s%n", 1 / 0.0);
        System.out.printf("9.5. %s%n", 1 / -0.0);
        System.out.printf("9.6. %s%n", 1 / 0.0 == 1 / 0.0);
        System.out.printf("9.7. %s%n", 1 / 0.0 == -(1 / 0.0));
        System.out.printf("9.8. %s%n", 1 / 0.0 == -(-1 / 0.0));

        // 10 при вычислении Java делает автоматические преобразования к большему типу но
        // !!! Если результат вышел за пределы long, то излишок отбрасывается
        // и результат может зайти в зону отрицательных значений
        System.out.printf("10. %s%n", 1111111111111111111L * 12312);
        System.out.printf("11. %s%n", 999999999 * 999999999);
        // 12 Java может преобразовать большое число в маленькое, при этом отбросит лишнее
        System.out.printf("12. %s%n", (int) 999999999999999.567d * 444444444);


        float x1 = 3.5f, x2 = 3.7e6f, x3 = -1.8E-7f, x4 = 0x1e;
        double z1 = 1.0, minus2e1 = -2e1, minus0x2p2 = -0x2p2;
        // Для десятичных чисел используется е - 2e1  2 умножить на 10 в первой степени
        // У hex чисел e является цифрой поэтому используют - p
        //    0x2.0p2 - 0x2.0 на два во второй степени
        // результат всегда выражается в Double

        System.out.printf("13: %s %s %s %s %s %s %s %n", x1, x2,
                BigDecimal.valueOf(x3).toPlainString(), x4, z1, minus2e1, minus0x2p2);

        System.out.printf("14. %s%n", -0x2E2 == -0x2P2);
        System.out.printf("14. %s%n", -0.8E1 == -0x2P2);

    }
}
